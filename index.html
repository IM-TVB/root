<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>2D PvP Fighting Game (Local)</title>
<style>
  html,body { height:100%; margin:0; background:#0b1220; display:flex; align-items:center; justify-content:center; font-family:Inter,system-ui,Segoe UI,Roboto,Arial;}
  #game { background: linear-gradient(#1b2430,#0e1218); border:6px solid #0f1724; box-shadow:0 12px 30px rgba(0,0,0,0.6); }
  .ui { color:#cfe8ff; width:800px; display:flex; justify-content:space-between; padding:8px 0 0; box-sizing:border-box; margin-bottom:6px; font-weight:600;}
  .hud { display:flex; gap:12px; align-items:center; }
  .hp { width:220px; height:18px; background:#2b2f36; border-radius:6px; overflow:hidden; box-shadow:inset 0 -3px 10px rgba(0,0,0,0.3);}
  .hp > .bar { height:100%; background:linear-gradient(90deg,#ff6b6b,#ff4d4d); width:100%; transition:width 0.1s linear;}
  .rounds { font-size:14px; opacity:0.9; }
  .center { text-align:center; color:#9fb8ff; font-weight:700; }
  canvas { display:block; }
  .info { font-size:13px; color:#9aa6bf; text-align:center; margin-top:8px; width:800px; }
  button { background:#1d2938; color:#cfe8ff; border:0; padding:8px 12px; border-radius:6px; cursor:pointer; }
  button:hover { filter:brightness(1.05) }
</style>
</head>
<body>

<div style="display:flex;flex-direction:column;align-items:center;">
  <div class="ui" style="width:800px;">
    <div class="hud">
      <div style="display:flex;flex-direction:column;">
        <div style="display:flex;gap:8px;align-items:center;"><div style="width:10px;height:10px;background:#6eb9ff;border-radius:50%"></div>Player 1</div>
        <div class="hp"><div id="hp1" class="bar"></div></div>
      </div>
      <div class="rounds">Rounds: <span id="r1">0</span> - <span id="r2">0</span></div>
    </div>

    <div class="center">2D PvP Fighting — Local</div>

    <div class="hud" style="justify-content:flex-end;">
      <div style="display:flex;flex-direction:column;align-items:flex-end;">
        <div style="display:flex;gap:8px;align-items:center;"><div style="width:10px;height:10px;background:#ffb86b;border-radius:50%"></div>Player 2</div>
        <div class="hp"><div id="hp2" class="bar" style="background:linear-gradient(90deg,#ffd86b,#ffb86b);"></div></div>
      </div>
    </div>
  </div>

  <canvas id="game" width="800" height="450"></canvas>

  <div style="display:flex;gap:12px;margin-top:10px;">
    <button id="restart">Restart Match</button>
    <button id="toggleDebug">Toggle Debug</button>
  </div>

  <div class="info">
    Controls — P1: A/D left-right, W jump, S crouch, F attack. P2: ←/→ move, ↑ jump, ↓ crouch, L attack.
    <br>Tip: Modify values in code to tweak physics, attack ranges, and health.
  </div>
</div>

<script>
/* ====== Game constants ====== */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

let debug = false;

/* ====== Utility ====== */
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function rectsOverlap(a,b){
  return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
}

/* ====== Entities (players) ====== */
class Player {
  constructor(opts){
    this.name = opts.name;
    this.color = opts.color;
    this.x = opts.x; this.y = opts.y;
    this.w = 42; this.h = 72;
    this.vx = 0; this.vy = 0;
    this.facing = opts.facing || 1; // 1 right, -1 left
    this.onGround = false;
    this.maxHealth = 100; this.health = 100;
    this.isAttacking = false;
    this.attackTimer = 0;
    this.hitCooldown = 0;
    this.inputs = {left:false, right:false, jump:false, down:false, attack:false};
    this.stun = 0;
    this.score = 0;
    this.respawnTimer = 0;
  }

  getHitbox(){
    // body
    return {x:this.x, y:this.y, w:this.w, h:this.h};
  }

  getAttackHitbox(){
    if(!this.isAttacking) return null;
    const reach = 44 + Math.abs(this.vx); // dynamic reach
    if(this.facing === 1){
      return {x: this.x + this.w, y: this.y + 16, w: reach, h: 28, owner: this};
    } else {
      return {x: this.x - reach, y: this.y + 16, w: reach, h: 28, owner: this};
    }
  }

  takeHit(damage, knock){
    if(this.hitCooldown > 0 || this.respawnTimer>0) return false;
    this.health -= damage;
    this.vx += knock.x;
    this.vy += knock.y;
    this.stun = 12;
    this.hitCooldown = 12;
    if(this.health <= 0){
      this.health = 0;
      return true; // died
    }
    return false;
  }

  update(){
    if(this.respawnTimer > 0){
      this.respawnTimer--;
      return;
    }

    // apply inputs if not stunned
    if(this.stun <= 0){
      const accel = 0.9;
      if(this.inputs.left && !this.inputs.right){
        this.vx = clamp(this.vx - accel, -8, 8);
        this.facing = -1;
      } else if(this.inputs.right && !this.inputs.left){
        this.vx = clamp(this.vx + accel, -8, 8);
        this.facing = 1;
      } else {
        // friction
        this.vx *= 0.78;
        if(Math.abs(this.vx) < 0.12) this.vx = 0;
      }

      if(this.inputs.jump && this.onGround){
        this.vy = -12.8;
        this.onGround = false;
      }

      // attacks
      if(this.inputs.attack && !this.isAttacking && this.attackTimer <= 0){
        this.isAttacking = true;
        this.attackTimer = 16; // frames attack lasts
      }
    } else {
      // can still be moved slightly
      this.vx *= 0.95;
      this.stun--;
    }

    // attack timer tick
    if(this.isAttacking){
      this.attackTimer--;
      if(this.attackTimer <= 0){
        this.isAttacking = false;
        this.attackTimer = 20; // cooldown before next attack
      }
    } else if(this.attackTimer > 0){
      this.attackTimer--;
    }

    if(this.hitCooldown > 0) this.hitCooldown--;

    // physics
    this.vy += 0.6; // gravity
    this.x += this.vx;
    this.y += this.vy;

    // ground collision
    const groundY = H - 40;
    if(this.y + this.h >= groundY){
      this.y = groundY - this.h;
      this.vy = 0;
      this.onGround = true;
    } else {
      this.onGround = false;
    }

    // stage bounds
    if(this.x < 12) { this.x = 12; this.vx *= -0.2; }
    if(this.x + this.w > W - 12) { this.x = W - 12 - this.w; this.vx *= -0.2; }

    // small air drag
    this.vx *= 0.998;
  }

  draw(){
    // body
    ctx.save();
    ctx.translate(this.x + this.w/2, this.y + this.h/2);
    // shadow
    ctx.restore();

    // draw body rect
    ctx.fillStyle = this.color;
    ctx.fillRect(this.x, this.y, this.w, this.h);

    // face indicator (simple)
    ctx.fillStyle = '#fff';
    const eyeX = this.facing === 1 ? this.x + this.w - 14 : this.x + 8;
    ctx.fillRect(eyeX, this.y + 18, 6, 6);

    // attack hitbox debug
    if(debug){
      const ah = this.getAttackHitbox();
      if(ah){
        ctx.strokeStyle = '#ff0';
        ctx.strokeRect(ah.x, ah.y, ah.w, ah.h);
      }
      // body
      ctx.strokeStyle = '#0f0';
      ctx.strokeRect(this.x, this.y, this.w, this.h);
    }
  }

  respawnAt(x,y){
    this.x = x; this.y = y; this.vx = 0; this.vy = 0; this.health = this.maxHealth;
    this.respawnTimer = 30; // brief invul / wait
    this.hitCooldown = 0; this.stun = 0; this.isAttacking = false; this.attackTimer = 0;
  }
}

/* ====== Setup players ====== */
const p1 = new Player({name:'P1', color:'#6eb9ff', x:120, y:200, facing:1});
const p2 = new Player({name:'P2', color:'#ffb86b', x:600, y:200, facing:-1});

/* ====== Input handling ====== */
// P1: A/D, W jump, S down, F attack
// P2: Arrow keys, L attack
const keys = {};
window.addEventListener('keydown', e=>{
  if(e.key === 'a') p1.inputs.left = true;
  if(e.key === 'd') p1.inputs.right = true;
  if(e.key === 'w') p1.inputs.jump = true;
  if(e.key === 's') p1.inputs.down = true;
  if(e.key === 'f') p1.inputs.attack = true;

  if(e.key === 'ArrowLeft') p2.inputs.left = true;
  if(e.key === 'ArrowRight') p2.inputs.right = true;
  if(e.key === 'ArrowUp') p2.inputs.jump = true;
  if(e.key === 'ArrowDown') p2.inputs.down = true;
  if(e.key === 'l') p2.inputs.attack = true;

  // debug toggle via Shift+D
  if(e.key === 'D' && (e.shiftKey || e.key === 'D')){}
});
window.addEventListener('keyup', e=>{
  if(e.key === 'a') p1.inputs.left = false;
  if(e.key === 'd') p1.inputs.right = false;
  if(e.key === 'w') p1.inputs.jump = false;
  if(e.key === 's') p1.inputs.down = false;
  if(e.key === 'f') p1.inputs.attack = false;

  if(e.key === 'ArrowLeft') p2.inputs.left = false;
  if(e.key === 'ArrowRight') p2.inputs.right = false;
  if(e.key === 'ArrowUp') p2.inputs.jump = false;
  if(e.key === 'ArrowDown') p2.inputs.down = false;
  if(e.key === 'l') p2.inputs.attack = false;
});

/* ====== Game stage & loop ====== */
let last = performance.now();
let running = true;

function update(dt){
  if(!running) return;

  p1.update();
  p2.update();

  // resolve attacks
  resolveAttacks(p1,p2);
  resolveAttacks(p2,p1);

  // check death
  checkDeath(p1,p2);
  checkDeath(p2,p1);
}

function resolveAttacks(attacker, defender){
  if(attacker.respawnTimer>0) return;
  const ah = attacker.getAttackHitbox();
  if(!ah) return;
  const dh = defender.getHitbox();
  if(rectsOverlap(ah, dh)){
    // successful hit
    const didDie = defender.takeHit(12 + Math.round(Math.abs(attacker.vx)*0.6), {x: 6 * attacker.facing + attacker.vx*0.3, y: -6});
    // small hit reaction
    attacker.vx *= 0.6;
    // brief invul via hitCooldown is handled in takeHit
    if(didDie){
      attacker.score++;
      // award round and respawn defender
      handleRoundWin(attacker, defender);
    }
  }
}

function checkDeath(player, other){
  // fall out of stage -> instant death
  if(player.y > H + 120 && player.respawnTimer===0){
    other.score++;
    handleRoundWin(other, player);
  }
}

function handleRoundWin(winner, loser){
  // increment UI rounds
  document.getElementById('r1').textContent = p1.score;
  document.getElementById('r2').textContent = p2.score;
  // respawn loser at center with small delay
  loser.respawnAt((loser === p1 ? 120 : 600), 160);
  // respawn winner slightly
  winner.respawnAt((winner === p1 ? 220 : 500), 160);
  // temporary screen flash or effect could be here
}

/* ====== Render ====== */
function draw(){
  // background
  ctx.clearRect(0,0,W,H);
  // sky gradient
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0, '#0f1724');
  g.addColorStop(1, '#07101a');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);

  // stage ground
  ctx.fillStyle = '#1b2630';
  ctx.fillRect(0, H-40, W, 40);
  // platform center
  ctx.fillStyle = '#0f1724';
  ctx.fillRect(80, H-120, W-160, 12);

  // players
  p1.draw();
  p2.draw();

  // UI health bars update
  const hp1 = document.getElementById('hp1');
  const hp2 = document.getElementById('hp2');
  hp1.style.width = (p1.health / p1.maxHealth * 100) + '%';
  hp2.style.width = (p2.health / p2.maxHealth * 100) + '%';

  if(debug){
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.fillRect(0,0,W,H);
    // draw velocities
    ctx.fillStyle = '#cfe8ff';
    ctx.fillText(`P1 vx:${p1.vx.toFixed(2)} vy:${p1.vy.toFixed(2)} stun:${p1.stun}`, 12, 20);
    ctx.fillText(`P2 vx:${p2.vx.toFixed(2)} vy:${p2.vy.toFixed(2)} stun:${p2.stun}`, 12, 36);
  }
}

/* ====== Main loop ====== */
function loop(ts){
  const dt = Math.min(32, ts - last);
  last = ts;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ====== Buttons ====== */
document.getElementById('restart').addEventListener('click', ()=>{
  p1.score = 0; p2.score = 0;
  document.getElementById('r1').textContent = 0;
  document.getElementById('r2').textContent = 0;
  p1.respawnAt(120,160); p2.respawnAt(600,160);
});
document.getElementById('toggleDebug').addEventListener('click', ()=>{ debug = !debug; });

/* ====== Quick tuning: expose for console tweaks ====== */
window.game = {p1,p2,ctx,canvas};
</script>

</body>
</html>